<!DOCTYPE html>
<html lang="en">
<head>
    <meta Commit labeling protocol="UTF-8">
    <title>Commit labeling protocol</title>
</head>
<body>


We base our taxonomy on the taxonomy of
<a href="https://www.semanticscholar.org/paper/Characteristics-of-application-software-maintenance-Lientz-Swanson/2821ee262ee92a8c5c5bb90cda7d0702e9f61af5?p2df">“Characteristics of Application Software Maintenance”</a>
The main difference in taxonomy is that we add a refactoring as a sub-category inside perfective.
Other than that, we provide detailed protocols referring to cases that are usualy not considered by the high level definition.

We divide commits into
<ol>
  <li>Corrective - <a href="corrective_protocol.html">bug fixes</a>.</li>
  <li>Adaptive - <a href="adaptive_protocol.html">implementation of new features</a>.</li>
  <li>Perfective - <a href="perfective_protocol.html">improvement of current system with out changing its functionality. Typically documentation or refactoring</a></li>
  <li>Refactor - <a href="refactor_protocol.html">improvement of system design without changing its functionality (part of perfective)</a></li>
  <li>Other - whatever not fall into the above. Should be a small category</li>
</ol>



<B>Task</B>

Our goal is to label git commit message and decide on its type.
A commit might have several types (e.g., corrective and refactor), hence each labeling protocol and label should be followed independently.


For each commit we should following fields:
<ol>
  <li>Is_Corrective, taking the values, True, False and ? (as intermediate value)</li>
  <li>Is_Adaptive, taking the values, True, False and ? (as intermediate value)</li>
  <li>Is_Perfective, taking the values, True, False and ? (as intermediate value)</li>
  <li>Is_Refactor, taking the values, True, False and ? (as intermediate value)</li>
  <li>Justification which is the reason based on the text for the classification.</li>
  <li>Certain, mark cases in which the annotator is not sure in the label</li>
  <li>Comment, free text adding more information</li>
</ol>




The labeling is based on the commit message for each commit.
Ideally this will be enough for the classification.
If needed, the commit content, linked ticket and other data can be used for finding the commit type.


<BR>
<B>Instructions</B>

<ol>
  <li>We consider only commit messages in English.</li>
  <li>In case of messages not in English, the comment should be “Not in English”.</li>
  <li>Unless we find an indication to a type, the default should be False.</li>
  <li>In case of uncertainty, the commit should be labeled by the option you consider most likely.
      Mark “Certain” as False and then describe the source of the uncertainty and the reasons to your decision in the comment.</li>
  <li>In case that it is hard to decide based on the commit message alone, one should check the commit content in git.
      The concept that we label is “Is the commit of the type?” and not “Does the commit message indicates the type”.
      Hence, if a fix indication is found in git, the commit should be labeled as True.</li>
  <li>The “Justification” field should contain the reason to the labeling, usuelly part of the commit message.</li>
  <li>In case of an other action, the justification should be “other action”</li>
  <li>In case of English text but no a specific term indicating a bug, the comment should be “No syntactic evidence”.
      This cases are rare. Consider text like “The previous implementation of the multiplication function returned 5 for mult(2,2).
      Now it returns 4.” The commit should be labeled as True since it is a fix, though some methods cannot identify it.</li>
  <li>Merge is a technical instrument.
      Its usage alone is not an indication regarding the content or being a bug fix. A merge commit should be judged by its content.</li>

</ol>


</body>
</html>